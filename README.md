# Задание №4. Функциональная Java

Ваше задание состоит из двух частей.

Первая - это реализация структуры данных, напоминающей иммутабельные списки из функциональных языков
программирования.

Вторая - это использование StreamAPI, чтобы обрабатывать и группировать данные о кинофильмах.

## Задачи

### 1. Функциональный список (FList)

В функциональных языках программирования структуры данных зачастую являются неизменяемыми объектами.

Это значит, что если вы создали объект, то вы не можете его модифицировать - по крайней мере, не
напрямую.

Вместо этого язык предоставляет удобные средства для создания новых объектов на основе уже
существующих. Вместо мутации какого-то объекта (как это принято, например, в Java) вы создаете новые
объекты, которые переиспользуют какие-то из частей уже созданных объектов.

Иммутабельный список является каноническим примером такого подхода. Рассмотрим такой псевдокод:

```
val empty = nil
val oneElement = cons(1, nil)
val twoElements = cons(1, cons(2, nil))
```

Здесь `nil` - это обозначение пустого списка, а `cons` - конструктор, позволяющий создать новый
список, объединив элемент с уже существующим списком (обычно это называется голова и хвост
соответственно).

Иммутабельность дает интересные возможности - например, у двух разных списков может быть один и тот
же хвост:

```
val tail = cons(1, cons(2, cons(3, nil)))

val first = cons(10, tail)
val second = cons(20, tail)
```

Поскольку объект `tail` никогда не поменяется, его можно безопасно использовать при конструировании
других списков.

Java не является в полной мере функциональным языком программирования. Однако это не помешает нам
реализовать иммутабельный список, вдохновленный идеями, изложенными выше. Его использование будет
выглядеть примерно так:

```java
class Example {

  void main(String[] array) {
    FList<Integer> list = listOf(1, 2, 3); // сокращение от cons(1, cons(2, cons(3, empty()))

    FList<String> transformedList = map(filter(list, i -> i % 2 == 0), i -> i.toString());

    forEach(transformedList, s -> System.out.println(s));
  }
}
```

Вам необходимо реализовать два наследника
класса [FList](src/main/java/org/csc/java/spring2021/immutable/FList.java):

* [Cons](src/main/java/org/csc/java/spring2021/immutable/Cons.java)
* [Nil](src/main/java/org/csc/java/spring2021/immutable/Nil.java)

Также вам нужно реализовать методы для работы с функциональными списками в
классе [FListUtils](src/main/java/org/csc/java/spring2021/immutable/FListUtils.java).

**ВАЖНО**:

1. Мы намеренно не проставляли в коде `? extends` и `? super` - это упражнение оставлено для вас.
2. Часть тестов намеренно закомментирована, чтобы вам было проще начинать делать работу.
   Закомментированные тесты явно помечены с
   помощью [CommentedTestPlaceholderException](src/test/java/org/csc/java/spring2021/CommentedTestPlaceholderException.java)
   . В целиком выполненной работе все закомментированные тесты должны быть включены.

За выполнение этого задания вы получаете 7 баллов:

- 1 балл суммарно за `cons`, `empty` и `listOf`
- по одному баллу за `foldl` и `foldr`
- по одному баллу за `map`, `filter` и `concat` 
- 1 балл суммарно за вспомогательные функции (`equals`, `hashCode`, `toJavaList` и другие)

### 2. Запросы к базе данных с фильмами (MovieRepository)

Вам дается объект типа
[MovieDatabase](src/main/java/org/csc/java/spring2021/moviedatabase/MovieDatabase.java),
предоставляющий доступ к потоку информации о фильмах и актерах.

Ваша задача - реализовать методы
класса [MovieRepository](src/main/java/org/csc/java/spring2021/moviedatabase/MovieRepository.java),
используя StreamAPI и коллекторы.

Всего за это задание вы можете получить 3 балла:
- 1 балл суммарно за `collectTopRatedMoviesForAllTime` и `collectActorsOfGenreForPeriod`
- по одному баллу за `collectTopRatedMovieByActor` и `collectTopRatedMoviesByYears`

## Как сдавать

При создании вашего репозитория будет автоматически создан
[Pull Request для проверки](../../pull/1).

Вы должны закоммитить своё решение в ветку `main` (это ветка вашего репозитория по-умолчанию), и эти
коммиты автоматически добавятся в Pull Request.

**Этот пулл-реквест не нужно мерджить и не нужно закрывать!!!**

Когда вы будете готовы к первой проверке, сделайте следующее:

- Добавьте к этому пулл-реквесту лейбл `ready-for-review`. Это можно сделать в правой части страницы
  с пулл-реквестом в меню `Labels`.
- Отправьте ссылку на этот пулл-реквест в качестве решения
  на [сайте CSC](https://my.compscicenter.ru/).

В дальнейшем, если вы внесли исправления и хотите запросить очередную проверку, просто повторно
запросите ревью от преподавателя, который вас уже проверял:

![Анимация того, как запросить ревью](https://i.stack.imgur.com/H2XaO.gif)

Если у вас возникают проблемы на каком-то из этих шагов, пожалуйста, сообщите об этом в Slack. Чем
быстрее вы это сделаете, тем быстрее мы поможем вам.

